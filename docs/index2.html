<html>
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
  <title>Underscore.lua</title>

  <link rel="stylesheet" type="text/css" media="all" href="css/reset.css" />
  <link rel="stylesheet" type="text/css" media="all" href="css/text.css" />
  <link rel="stylesheet" type="text/css" media="all" href="css/960.css" />
  <link rel="stylesheet" type="text/css" media="all" href="css/main.css" />

</head>
<body>
  <div class="container_12">
    <div class="grid_3 function_index" style="background-color: red;">
      <h3>Map Functions</h3>
      <ul>
        <li><a href="#map">_.map(list, func)</a></li>
        <li><a href="#each">_.each(list, func)</a></li>
        <li><a href="#select">_.select(list, func)</a></li>
        <li><a href="#reject">_.reject(list, func)</a></li>
        <li><a href="#invoke">_.invoke(list, function_name, [...])</a></li>
        <li><a href="#pluck">_.pluck(list, propertyName)</a></li>
      </ul>
      
      <h3>Reduce Functions</h3>
      <ul>
        <li>_.reduce(list, memo, func)</li>
        <li>_.detect(list, func)</li>
        <li>_.all(list, [func])</li>
        <li>_.any(list, [func])</li>
        <li>_.include(list, value)</li>
        <li>_.min(list, [func])</li>
        <li>_.max(list, [func])</li>
        <li>_.to_array(list)</li>
      </ul>      

      <h3>Array Functions</h3>
      <ul>        
        <li>_.reverse(list)</li>
        <li>_.sort(iter, comparison_func)</li>
        <li>_.first(array, n)</li>
        <li>_.rest(array, index)</li>
        <li>_.slice(array, start_index, length)</li>
        <li>_.flatten(array)</li>
        <li>_.push(array, item)</li>
        <li>_.join(array, separator)</li>        
      </ul>      

      <h3>Table Functions</h3>
      <ul>
      </ul>      

      <h3>Function Functions</h3>
      <ul>
      </ul>      
    </div>
    <div class="grid_8">
      <h1>Underscore.lua</h1>

      <p>
        Underscore.lua is a Lua library that provides a set of utility functions for dealing with
        iterators, arrays, tables, and functions. It is <b>heavily</b> inspired by 
        <a href="http://documentcloud.github.com/underscore">Underscore.js</a>. Although the code was
        not referenced during the writing of this library the documentation, examples, and api are basically
        ripped off from them.
      </p>
    
      <h2>Installing</h2>
      <p>The source code is <a href="http://github.com/mirven/underscore.lua">available</a> at Github.</p>
      <p>It can be installed with <a href="http://www.luarocks.org">LuaRocks</a> via: <code>luarocks install underscore.lua --from=http://marcusirven.s3.amazonaws.com/rocks/</code></p>
      <p>Alternatively underscore.lua can be downloaded directly from <a href="http://github.com/mirven/underscore.lua/raw/0.2-1/lib/underscore.lua">here</a>.</p>
    
      <h2>Object-Oriented and Functional Styles</h2>
      <p>
        You can use Underscore in either an object-oriented or a functional style, 
        depending on your preference. The following two lines of code are identical 
        ways to double a list of numbers.
      </p>
      <pre>
        _.map({1, 2, 3}, function(n) return n * 2 end)
        _({1, 2, 3}):map(function(n) return n * 2 end)
      </pre>
      <p>
        Using the object-oriented style allows you to chain together methods. Calling chain on a 
        wrapped object will cause all future method calls to return wrapped objects as well. When 
        you've finished the computation, use value to retrieve the final value. Here's an example 
        of chaining together a map/flatten/reduce, in order to get the word count of every word in a song.
      </p>
      <pre>
        local lyrics = {
          { line = 1, words = "I'm a lumberjack and I'm okay" },
          { line = 2, words = "I sleep all night and I work all day" },
          { line = 3, words = "He's a lumberjack and he's okay" },
          { line = 4, words = "He sleeps all night and he works all day" }
        }
      
        _(lyrics):chain()
          :map(function(line) 
            local words = {}
            for w in line.words:gmatch("%S+") do
              words[#words+1] = w   
            end
            return words
          end)
          :flatten()
          :reduce({}, function(counts, word)
            counts[word] = (counts[word] or 0) + 1
            return counts
          end):value()
      </pre>
      <p>Note: This can be written even more succinctly as (notice the map function):</p> 
      <pre>
        _(lyrics):chain()
          :map(function(line) return _.to_array(line.words:gmatch("%S+")) end)
          :flatten()
          :reduce({}, function(counts, word)
            counts[word] = (counts[word] or 0) + 1
            return counts
          end):value()
      </pre>
      
      <h2>Functions</h2>
      
      <h3>Map Functions</h3>

      <div id="map">
        <p><strong>map</strong><code>_.map(iter, func)</code><p>
        <p class="description">Produces a new array by mapping each value in iter through a transformation function.<p>
        <pre>
          _.all({2,4,8}, function(i) return i%2 end)
        </pre>
      </div>

      
    </div>
  </div>
</body>
</html>